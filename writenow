#!/bin/bash
#
# writenow - A simple bash script to write in edit-free mode
#
# Copyright (C) 2023  Salar Nosrati-Ershad
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# Global variables
readonly VERSION="v0.1.0"
readonly PROMPT="> "
declare -r -i MAX_ROWS=3
declare TEMINATED=false
declare -i ROWS=0
declare LINES=()

# Raise error on stderr
# Arguments: error message
# Output: error message on stderr
function err() {
  echo "Error: $*" >&2
}

# Show version information
# Globals: VERSION
# Output: version information on stdout
function version() {
  echo "writenow ${VERSION}"
  echo "Copyright (C)  2023 Salar Nosrati-Ershad"
  echo "License GPLv3: GNU GPL version 3 <https://gnu.org/licenses/gpl.html>"
  echo "This is free software: you are free to change and redistribute it."
  echo "There is NO WARRANTY, to the extent permitted by law."
}

# Show usage information
# Output: usage and version information on stdout
function usage() {
  version
  echo
  echo "Usage: writenow [OPTION]..."
  echo
  echo "  -h, --help      display this help and exit"
  echo "  -v, --version   display version information and exit"
}

# Parse arguments
# Arguments: first arguments
# Output: error message on stderr and exit if arguments are invalid
# Return: 0 if arguments are valid, 1 otherwise
function parse_args() {
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    -v|--version)
      version
      exit 0
      ;;
    *)
      err "invalid argument:" "$1"
      usage
      exit 1
      ;;
  esac
}

# Check if a dependency is exist
# Arguments: dependency name
# Output: error message on stderr and exit if dependency is not installed
# Return: 0 if dependency is installed, 1 otherwise
function check_dependency() {
  if ! command -v "$1" > /dev/null; then
    err "dependency not found:" "$1"
    exit 1
  fi
}

# Write LINES in an output file
# Arguments: output file name
# Globals: LINES
function write_lines() {
  for row in "${LINES[@]}"; do
    echo "${row}" >> "$1"
  done
}

# Handle termination signals
# Globals: TEMINATED
function handle_termination() {
  if ! $TEMINATED; then
    TEMINATED=true
    echo
    read -r -p "File name to write: " file
    write_lines "${file}"
    exit 0
  else
    echo
    exit 0
  fi
}

# Clear prompt lines if exceeds MAX_ROWS
# Globals: ROWS, MAX_ROWS
function reset_prompt_lines() {
  if [[ ROWS -gt MAX_ROWS ]]; then
    tput cuu "${ROWS}"
    tput dl "$((ROWS - MAX_ROWS))"
    ROWS=$MAX_ROWS
    tput cud "${ROWS}"
  fi
}

# Prompt loop
# Globals: PROMPT, LINES, ROWS
function prompt_loop() {
  local line
  while true; do
    read -r -p "${PROMPT}" line
    ROWS+=1
    LINES+=("${line}")
    reset_prompt_lines
  done
}

# Main function
function main() {
  # parse arguments
  if [[ $# -gt 0 ]]; then
    parse_args "$1"
  fi

  # Check dependencies
  # Busybox dependencies are not checked
  check_dependency "tput" # part of ncurses

  # handle termination signals
  trap handle_termination SIGINT SIGTERM

  prompt_loop
}


main "$@"
